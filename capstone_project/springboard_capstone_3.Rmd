---
title: "Springboard Capstone 3"
author: "Carlee Price"
date: "July 8, 2017"
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## A STUDY ON THE ANGEL INVESTING LANDSCAPE AND OUTCOMES FOR INVESTORS

WHAT WE HAVE:

A Crunchbase data set that reports investments in seed-stage companies. This data is a sample, reflecting some portion of the total amount of activity in this space.  It was published in 2014 and reflected activity in the space up to that point.  We're going to select from the global, long-horizon data set those companies that received first funding in the US after 2007. 

The goal here is to characterise for potential investors in this space, what the range of potential outcomes (returns on their invested capital) might be, and what proper portfolio construction looks like and means for those same returns.

## PART I: WORKING WITH THE CRUNCHBASE DATA

#### a) LOAD & TRANSFORM 

```{r}
#read in the file that includes all the company information for this database
allcompanies = read.csv("companies.csv")
```

```{r}
#keep only the companies that are US-based
companies <- subset(allcompanies, country_code == "USA")
#we also want to keep only the companies with first_funded_at dates of 2007 or later
#first cast this column as a date
companies$first_funding_at <- format(as.Date(companies$first_funding_at), "%Y/%m/%d")
#then screen for chosen date
companies <- subset(companies, first_funding_at >= '2007/01/01')
nrow(companies)
#check for completeness in the resulting set; list of rows that have missing values
nrow(companies[!complete.cases(companies),])
colnames(companies)
```

After subsetting the data, we have 25,837 rows of which 4,688 are incomplete.  Some of this missing data won't bother us, but in the case of funding_total_usd, it is important.  Our study focuses on companies that raise money from outsiders.  Our conclusions will largely depend on what happens to the dollars these companies raise.  If we don't know in a case how may dollars are involved, it becomes difficult to draw conclusions.  So we'll remove any companies for which the funding total shows N/A.  



This is a sufficiently robust set to draw conclusions about the space.

####Exploration #1): How often do investors see their money returned (company acquired) compared to the frequency with which they lose all their money (company closed)?

Transform the funding column into useable form (by stripping punctuation, converting to integer) and changing blanks in status column to read "unknown". Here is where we remove companies that lack information on funding totals.  Let's see how these companies performed over the study horizon, how many remained operational.  

```{r}
companies$funding_total_usd <- as.numeric(gsub("[[:punct:]]", "", companies$funding_total_usd))
companies <- subset(companies, funding_total_usd > 1)
nrow(companies) 
levels(companies$status)[1] <- "unknown"
table(companies$status)
```

This is our first look at the win/loss ratio in this space.  Counting exits as a win (7.5%) and closeds as a loss (4.8%) looks encouraging; the ratio is > 1.  Will the numbers be different if we look at just one vintage of companies?  Let's look just at companies that were funded in 2007, not after.  There are 1276 rows in this subset.


```{r}
companies07 <- subset(companies, first_funding_at <= '2007/12/31')
nrow(companies07)
table(companies07$status)
```

Here we see the wins (25.5%) and losses (13.2%) are much higher; an even better ratio.  It seems that spending more time in the market leads to more resolutions (closure or acquisition).  Remember this data was captured in 2014. 

#### #2. What about dollar-on-dollar returns?

Let's get more granular, and look not just at the outcome but at the degree of success.  Closure of a business can only result in 100% loss but an exit can clearly generate > 100% returns.  We're working towards a picture of total portfolio returns.

Add two new data sets from the same source: funding rounds (amounts raised) and acquisitions (exit values).  Both will need to be tidied in a similar fashion to our companies table.   

```{r}
allrounds = read.csv("rounds.csv")
rounds <- subset(allrounds, company_country_code == "USA")
rounds$raised_amount_usd <- as.numeric(gsub("[[:punct:]]", "", rounds$raised_amount_usd))
allacquisitions = read.csv("acquisitions.csv")
acquisitions <- subset(allacquisitions, company_country_code == "USA")
acquisitions$price_amount <- as.numeric(gsub("[[:punct:]]", "", acquisitions$price_amount))
```

In the process of this exploration, some data-quality issues emerge.  We address two of these here.  

First, in acquisitions set: Riot Games was acquired by Tenecet for 400Mm, not the USD 4,000 noted. 

Second, in companies set: Aptalis Pharma is listed as having raised a single round (173k seed capital) and then proceeding to exit for $2.9Bn.  That would create an impressive return indeed for funders.  The reality is that the company actually was spun out from the merger of two established pharmaceutical giants.  At the date of formation had seven branded products in market, and a robust development pipeline.  There was far more than USD 173k in value within the company.  Because this is incorrect and because the actual nature of the enterprise disqualifies it from this (startup) data set, it comes out. 

```{r}
acquisitions$price_amount[5344] <- 400000000
```

We're not able to screen these new tables for "first funding" date, as we did with our companies table.  So instead we'll use a left join, which allows us to start with the screened companies table and add information from the new data sets only where it matches.  lib

```{r}
companies2 <- subset(companies, select = c(name, funding_total_usd, status, state_code, region, city, funding_rounds, founded_year, first_funding_at))
#remove Aptalis Pharma
companies2 <- companies2[-c(1584), ]  
acquisitions2 <- subset(acquisitions, select = c(company_name, company_state_code, company_region, company_city, acquirer_name, acquired_at, price_amount, price_currency_code))
#we can't simply join on name, since there are a number of unique companies that share a name.  
#create a new column namecity that includes both the name of the company & the city of its founding
companies2$namecityyear <- paste(companies2$name, companies2$city)
acquisitions2$namecity <- paste(acquisitions2$company_name, acquisitions2$company_city)
#then join them
joinedset <- merge(x = companies2, y = acquisitions2, by = "namecity", all.x = TRUE)
```

There are duplicate rows in this merged dataframe.  If we screen using unique, we remove 12 rows that are perfectly identical. There are also companies in here which have been acquired twice (see: Forrst).  Stakeholders may in this case be getting paid twice, but not necessarily.  Further, the amount of the gain in the second case would be the differential between that and the first bid, rather than the entire amount.  This gets tricky, but can be properly addressed only where both prices (acquisition 1 and acquisition 2) are disclosed.

```{r}
library(dplyr)
nrow(joinedset)
#subset(joinedset, name == "Catch.com")
#this one and 11 others can be eliminated with:
joinedset <- distinct(joinedset, name, first_funding_at, acquired_at, .keep_all = TRUE)
nrow(joinedset)
```

Because we want to look at companies that were seed or angel funded (they may have ultimately raised a venture round, but necessarily began with seed money), we create a subset of the "rounds" data (again creating a unique identifier namecity) that includes seed fundings only, then left join the joined set to this list.

```{r}
rounds2 <- subset(rounds, select = c(company_name, company_city, funding_round_type, funded_at, raised_amount_usd))
#rounds2 <- subset(rounds2, rounds2$funding_round_type %in% c("seed", "angel"), drop = TRUE)
rounds2$namecity <- paste(rounds2$company_name, rounds2$company_city)
joinedset2 <- merge(x = joinedset, y = rounds2, by = "namecity", all.x = TRUE)
joinedset2 <- subset(joinedset2, joinedset2$funding_round_type %in% c("seed", "angel"), drop = TRUE)
```

And we have to filter out for repeats again.

```{r}
nrow(joinedset2)
joinedset2 <- distinct(joinedset2, name, first_funding_at, acquired_at, .keep_all = TRUE)
nrow(joinedset2)
```

Now we're ready to look at returns.  Angels want to see exits, as that's the only way they're getting the money back, and the source of their returns.  Our "status" field tells us which companies have been acquired and from that we got % exits (successes). We also want dollar-on-dollar % return, which requires acquisition price information (numerator) in addition to total funding information (denominator). 

```{r}
nrow(joinedset2)
#subset for where acquisition price information is disclosed
test <- subset(joinedset2, price_amount > 1, funding_total_usd >1)
nrow(test)
#create a new column that shows total $ returned to investors against total $ raised
test$return <- test$price_amount/test$funding_total_usd
#use sum here instead of averaging the test$return column as it's more reflective
sum(test$price_amount)/sum(test$funding_total_usd, na.rm = TRUE)
```

Only 110 of the 8151 companies described as "acquired" in our joined set include pricing information. Still a reasonable sample size, and the numbers are encouraging (23.9X return on total amount raised) but we wander into speculative territory if we fail to understand the biases in the sample (is it fair to say that acquisitions with price disclosed are generally more or less generous to investors?) extrapolate to conclusions about the population. 

If we consider just those companies with disclosed acquisition prices, compared to the total amount raised across the data set, what does that tell us? So if all of the companies that were not acquired, or were but did not disclose the acquisition price, were ultimately worth $0 what would returns on this money be (annualized IRR)?

```{r}
(sum(joinedset2$funding_total_usd, na.rm = TRUE)/sum(joinedset2$price_amount, na.rm = TRUE))^(1/7)-1
```

And the same just for our 2007 group:

```{r}
joinedset07 <- subset(joinedset2, first_funding_at <= '2007/12/31')
(sum(joinedset07$funding_total_usd, na.rm = TRUE)/sum(joinedset07$price_amount, na.rm = TRUE))^(1/7)-1
```

10 - 11% is not a very good return, considering the amount of risk investors in this space take on.  But again, this is just the reported cash in hand return for companies and to assume that all others in the data set were worthless is not realistic.

Another approach is to annualise the return figure, then take an average.

```{r}
#first convert acquired_at to proper date format
test$acquired_at <- format(as.Date(test$acquired_at), "%Y/%m/%d")
test$age_at_acquisition <- (as.Date(test$acquired_at) - as.Date(test$first_funding_at))
test$annual_return <- (test$return ^ (365.25/as.integer(test$age_at_acquisition)) - 1)
plot(test$annual_return, log = "y")

```

Here we see more troubling data, companies that were allegedly in the market for weeks that were sold for multiples of the invested amounts (Renaissance Learning).  21 companies whose "first funding" date is actually after the date it was acquired, and three more that were funded & acquired on the same date.  10 that were in the market for less than 90 days.  


In order to capture a true picture of what total returns are, we need to add several pieces to this:

1) companies that were acquired for an undicslosed amount
2) companies that were acquired outside of the study timeframe

#### #3.  Do companies that raise more money generate better returns for their stakeholders?  

We can also use our returns column to draw some conclusions about returns relative to amounts raised. The companies we hear about in the press tend to be frequently in front of investors; they're cash-consumptive and generally percieved as fancy.  But do these companies outperform their less capital-intensive peers?  A regression analysis should give a clue.

```{r}
library(ggplot2)
ggplot(test, aes(funding_total_usd, return)) +
 geom_point(aes(color = funding_rounds)) + 
 scale_color_gradient(low = "green", high = "blue") +
 geom_smooth(method ="lm") +
 scale_y_continuous(trans = "log2") +
  scale_x_continuous(trans = "log2")
```

The slope here is negative, which tells us that companies which raise more tend to return less dollar-for-dollar.  This may suprise some.

Next we factor these companies by returns, and look at the funding characteristics (amounts raised) by bucket.

```{r}
#set breaks for each funding bucket, levels came about through trial & error
grp <- c(0, 1, 5, 15, 35, 20000)
#set factors & assign names
test$rfact = cut(test$return, breaks = grp,labels=c('Subpar','Low', 'Medium','High', 'Bananas'), ordered = TRUE)
#create a boxplot
#plot(x = test$rfact, y = test$funding_total_usd, log = 'y', ylab = "funds raised", xlab = "quality of return")
ggplot(test, aes(x=rfact, y=funding_total_usd)) + geom_boxplot() + scale_y_continuous(trans = "log")
```

```{r}
ggplot(test, aes(rfact, funding_total_usd)) + geom_boxplot(colour = "#3366FF") +
  geom_jitter(width = 0.1, colour = "blue") +
  scale_y_continuous(trans = "log")
```

Here again we can see that companies are most likely to appear generate "bananas" returns if they've raised less money.  Likewise, those companies that have raised the most are in the lower-tier returns buckets.  Interesting!

Is it a statistically significant relationship?  Let's get the z score.

```{r}
#there must be an easier way to do this
ftusd <- sd(test$funding_total_usd, na.rm = TRUE)
ftumn <- mean(test$funding_total_usd, na.rm = TRUE)
a <- subset(test, test$rfact == "Bananas")
amean <- mean(a$funding_total_usd)
(amean - ftumn)/(ftusd/(sqrt(nrow(a))))
```

```{r}
b <- subset(test, test$rfact == "Subpar")
bmean <- mean(b$funding_total_usd)
(bmean - ftumn)/(ftusd/(sqrt(nrow(b))))
```

Returns in the Subpar category are much more of an outlier than those in the Bananas category. Raising large amounts of money is very coincident with lower returns.

We can get into SQL-like queries by using the dplyr pipe operator.  Let's summarise some statistics by factor.

```{r}
test %>%  group_by(rfact) %>% 
          summarise(raised = mean(funding_total_usd), rounds = mean(funding_rounds), return = mean(return))
```

We can also have a look at how well these characteristics interact with each other.  

Let's start by building a predictor model from the set of medium returns (5 - 15X):

```{r}
medset <- subset(test, rfact == "Medium")
fit = lm(return ~ funding_total_usd, medset) # Run a regression analysis
par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fit)
par(mfrow=c(1,1))
```
